<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Àjọṣe - Reactive Relationships - Ifá-Lang</title>
    <meta name="description"
        content="Learn about Àjọṣe, the reactive relationship model in Ifá-Lang for handling events and state changes.">
    <link rel="stylesheet" href="js/common.css">
    <script src="js/nav.js" defer></script>
    <script src="js/common.js" defer></script>
</head>

<body>
    <div id="nav-placeholder"></div>

    <!-- Breadcrumbs -->
    <div class="breadcrumbs">
        <div class="breadcrumbs-container">
            <ul class="breadcrumb-list">
                <!-- Breadcrumbs will be generated by JavaScript -->
            </ul>
        </div>
    </div>
    <div class="container">
        <header>
            <h1>⚡ Àjọṣe - Reactive Relationships</h1>
            <p style="color: var(--text-dim);">Signal-based reactivity with automatic dependency tracking</p>
        </header>

        <h2>What is Àjọṣe?</h2>
        <p><strong>Àjọṣe</strong> (Yoruba: "relationship") is Ifá-Lang's reactive programming engine. It enables
            automatic updates when data changes, similar to SolidJS or Vue's Composition API.</p>

        <div class="concept">
            <div class="concept-item">
                <h4>📡 Signal</h4>
                <p>Reactive primitive that holds a value and notifies subscribers on change</p>
            </div>
            <div class="concept-item">
                <h4>🔄 Computed</h4>
                <p>Derived value that auto-updates when dependencies change</p>
            </div>
            <div class="concept-item">
                <h4>💥 Effect</h4>
                <p>Side-effect that runs when tracked signals change</p>
            </div>
        </div>

        <h2>Signals</h2>
        <div class="method">
            <h3>Signal.new(value) / Ami.tuntun(iye)</h3>
            <p>Create a reactive signal with an initial value.</p>
            <pre><code>// Create signals
ayanmo count = Signal.new(0);
ayanmo name = Ami.tuntun("Ifá");

// Read value
Irosu.fo(count.get());  // 0

// Update value (triggers subscribers)
count.set(5);
count.update(|n| n + 1);  // Now 6</code></pre>
        </div>

        <div class="method">
            <h3>signal.subscribe(callback)</h3>
            <p>Register a callback to run when the signal changes.</p>
            <pre><code>ayanmo temperature = Signal.new(20);

// Subscribe to changes
temperature.subscribe(|temp| {
    Irosu.fo("Temperature changed to: " + temp);
});

temperature.set(25);  // Prints: "Temperature changed to: 25"</code></pre>
        </div>

        <h2>Computed Values</h2>
        <div class="method">
            <h3>Computed.from(signals, fn)</h3>
            <p>Create a derived value that auto-updates when source signals change.</p>
            <pre><code>ayanmo firstName = Signal.new("Ọba");
ayanmo lastName = Signal.new("Adé");

// Computed full name
ayanmo fullName = Computed.from([firstName, lastName], || {
    padapọ firstName.get() + " " + lastName.get()
});

Irosu.fo(fullName.get());  // "Ọba Adé"

lastName.set("Olúwọlé");
Irosu.fo(fullName.get());  // "Ọba Olúwọlé" (auto-updated!)</code></pre>
        </div>

        <h2>Effects</h2>
        <div class="method">
            <h3>Effect.create(fn) / Ipa.da(iṣẹ)</h3>
            <p>Run side-effects when tracked signals change.</p>
            <pre><code>ayanmo price = Signal.new(100);
ayanmo quantity = Signal.new(2);

// Effect: log total whenever price or quantity changes
Effect.create(|| {
    ayanmo total = price.get() * quantity.get();
    Irosu.fo("Total: $" + total);
});

// Changing either triggers the effect
quantity.set(5);  // Prints: "Total: $500"</code></pre>
        </div>

        <h2>Batching Updates</h2>
        <div class="method">
            <h3>batch(fn)</h3>
            <p>Group multiple signal updates to trigger effects only once.</p>
            <pre><code>ayanmo x = Signal.new(0);
ayanmo y = Signal.new(0);

Effect.create(|| {
    Irosu.fo("Position: (" + x.get() + ", " + y.get() + ")");
});

// Without batch: effect runs twice
// With batch: effect runs once
batch(|| {
    x.set(10);
    y.set(20);
});
// Prints: "Position: (10, 20)" only once</code></pre>
        </div>

        <h2>Use Cases</h2>
        <ul style="margin-left: 2rem; color: var(--text-dim);">
            <li><strong>UI State:</strong> Reactive forms, counters, toggles</li>
            <li><strong>Data Binding:</strong> Auto-sync model and view</li>
            <li><strong>Real-time Updates:</strong> Live data dashboards</li>
            <li><strong>Game State:</strong> Health bars, scores, inventories</li>
        </ul>

        <footer class="doc-footer">
            <p><a href="language/philosophy.html">← Language Philosophy</a> · <a href="api/api.html">API Reference</a>
            </p>
            <p><a href="index.html">Documentation Home</a></p>
        </footer>
    </div>
</body>

</html>