//! # Rust Transpiler
//!
//! Transpiles Ifá-Lang AST to Rust source code for native compilation.
//!
//! Supports all Yoruba terms like ewo (taboo), ase, ayanmo, etc.

use crate::ast::*;

/// Transpile an Ifá program to Rust source code
pub fn transpile_to_rust(program: &Program) -> String {
    let mut transpiler = RustTranspiler::new();
    transpiler.transpile_program(program)
}

struct RustTranspiler {
    indent: usize,
}

impl RustTranspiler {
    fn new() -> Self {
        RustTranspiler { indent: 1 }
    }

    fn indent_str(&self) -> String {
        "    ".repeat(self.indent)
    }

    fn transpile_program(&mut self, program: &Program) -> String {
        let mut body = String::new();

        for stmt in &program.statements {
            body.push_str(&self.transpile_statement(stmt));
            body.push('\n');
        }

        format!(
            r#"//! Generated by Ifá-Lang Transpiler
//! Àṣẹ - May it be so

use std::collections::HashMap;

/// Ifá Value type for dynamic typing
#[derive(Debug, Clone)]
pub enum IfaValue {{
    Int(i64),
    Float(f64),
    Str(String),
    Bool(bool),
    List(Vec<IfaValue>),
    Map(HashMap<String, IfaValue>),
    Nil,
}}

impl std::fmt::Display for IfaValue {{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {{
        match self {{
            IfaValue::Int(n) => write!(f, "{{}}", n),
            IfaValue::Float(n) => write!(f, "{{}}", n),
            IfaValue::Str(s) => write!(f, "{{}}", s),
            IfaValue::Bool(b) => write!(f, "{{}}", b),
            IfaValue::Nil => write!(f, "nil"),
            IfaValue::List(l) => write!(f, "{{:?}}", l),
            IfaValue::Map(m) => write!(f, "{{:?}}", m),
        }}
    }}
}}

impl std::ops::Add for IfaValue {{
    type Output = Self;
    fn add(self, other: Self) -> Self {{
        match (self, other) {{
            (IfaValue::Int(a), IfaValue::Int(b)) => IfaValue::Int(a + b),
            (IfaValue::Float(a), IfaValue::Float(b)) => IfaValue::Float(a + b),
            (IfaValue::Str(a), IfaValue::Str(b)) => IfaValue::Str(format!("{{}}{{}}", a, b)),
            _ => IfaValue::Nil,
        }}
    }}
}}

fn main() {{
{body}
    println!("\nÀṣẹ! (Success)");
}}
"#
        )
    }

    fn transpile_statement(&mut self, stmt: &Statement) -> String {
        let indent = self.indent_str();

        match stmt {
            Statement::VarDecl { name, value, .. } => {
                let val = self.transpile_expression(value);
                format!("{}let mut {} = {};", indent, name, val)
            }

            Statement::Assignment { target, value, .. } => {
                let target_str = self.transpile_assign_target(target);
                let val = self.transpile_expression(value);
                format!("{}{} = {};", indent, target_str, val)
            }

            Statement::Instruction { call, .. } => {
                let call_str = self.transpile_odu_call(call);
                format!("{}{};", indent, call_str)
            }

            Statement::If {
                condition,
                then_body,
                else_body,
                ..
            } => {
                let cond = self.transpile_expression(condition);
                let mut result = format!("{}if {} {{\n", indent, cond);

                self.indent += 1;
                for s in then_body {
                    result.push_str(&self.transpile_statement(s));
                    result.push('\n');
                }
                self.indent -= 1;

                result.push_str(&format!("{}}}", indent));

                if let Some(else_stmts) = else_body {
                    result.push_str(" else {\n");
                    self.indent += 1;
                    for s in else_stmts {
                        result.push_str(&self.transpile_statement(s));
                        result.push('\n');
                    }
                    self.indent -= 1;
                    result.push_str(&format!("{}}}", indent));
                }

                result
            }

            Statement::While {
                condition, body, ..
            } => {
                let cond = self.transpile_expression(condition);
                let mut result = format!("{}while {} {{\n", indent, cond);

                self.indent += 1;
                for s in body {
                    result.push_str(&self.transpile_statement(s));
                    result.push('\n');
                }
                self.indent -= 1;

                result.push_str(&format!("{}}}", indent));
                result
            }

            Statement::For {
                var,
                iterable,
                body,
                ..
            } => {
                let iter = self.transpile_expression(iterable);
                let mut result = format!("{}for {} in {} {{\n", indent, var, iter);

                self.indent += 1;
                for s in body {
                    result.push_str(&self.transpile_statement(s));
                    result.push('\n');
                }
                self.indent -= 1;

                result.push_str(&format!("{}}}", indent));
                result
            }

            Statement::Return { value, .. } => {
                if let Some(v) = value {
                    format!("{}return {};", indent, self.transpile_expression(v))
                } else {
                    format!("{}return;", indent)
                }
            }

            // Ẹsẹ (function) definition
            Statement::EseDef {
                name,
                params,
                body,
                visibility,
                ..
            } => {
                let vis = match visibility {
                    Visibility::Public => "pub ",
                    _ => "",
                };
                let params_str: Vec<String> = params
                    .iter()
                    .map(|p| format!("{}: IfaValue", p.name))
                    .collect();
                let mut result = format!(
                    "{}{}fn {}({}) -> IfaValue {{\n",
                    indent,
                    vis,
                    name,
                    params_str.join(", ")
                );

                self.indent += 1;
                for s in body {
                    result.push_str(&self.transpile_statement(s));
                    result.push('\n');
                }
                result.push_str(&format!("{}IfaValue::Nil\n", self.indent_str()));
                self.indent -= 1;

                result.push_str(&format!("{}}}", indent));
                result
            }

            // Odù (class) definition
            Statement::OduDef {
                name,
                body,
                visibility,
                ..
            } => {
                let vis = match visibility {
                    Visibility::Public => "pub ",
                    _ => "",
                };
                let mut result = format!("{}{}struct {} {{\n", indent, vis, name);
                result.push_str(&format!("{}    // TODO: Extract fields\n", indent));
                result.push_str(&format!("{}}}\n\n", indent));

                result.push_str(&format!("{}impl {} {{\n", indent, name));
                self.indent += 1;
                for s in body {
                    result.push_str(&self.transpile_statement(s));
                    result.push('\n');
                }
                self.indent -= 1;
                result.push_str(&format!("{}}}", indent));

                result
            }

            Statement::Import { path, .. } => {
                format!("{}// use {};", indent, path.join("::"))
            }

            // Àṣẹ - End/success statement
            Statement::Ase { .. } => {
                format!("{}std::process::exit(0);", indent)
            }

            // Èèwọ̀ - Taboo declaration (compile-time check, no runtime code)
            Statement::Taboo { source, target, .. } => {
                format!("{}// TABOO: {} cannot call {}", indent, source, target)
            }

            // Ewo - Runtime assertion
            Statement::Ewo {
                condition, message, ..
            } => {
                let cond = self.transpile_expression(condition);
                let msg = message
                    .clone()
                    .unwrap_or_else(|| "Assertion failed".to_string());
                format!("{}assert({}, \"{}\");", indent, cond, msg)
            }

            // Opon - Memory configuration directive (compile-time)
            Statement::Opon { size, .. } => {
                format!("{}// OPON: Memory size = {}", indent, size)
            }

            // Expression statement
            Statement::Expr { expr, .. } => {
                format!("{}{};", indent, self.transpile_expression(expr))
            }
        }
    }

    fn transpile_assign_target(&self, target: &AssignTarget) -> String {
        match target {
            AssignTarget::Variable(name) => name.clone(),
            AssignTarget::Index { name, index } => {
                format!("{}[{}]", name, self.transpile_expression(index))
            }
        }
    }

    fn transpile_odu_call(&self, call: &OduCall) -> String {
        let args: Vec<String> = call
            .args
            .iter()
            .map(|a| self.transpile_expression(a))
            .collect();

        // Map Odù domain calls to Rust implementations
        let domain_str = format!("{:?}", call.domain).to_lowercase();
        let method = call.method.to_lowercase();

        match (domain_str.as_str(), method.as_str()) {
            // ÌROSÙ - Console I/O
            ("irosu", "fo") | ("irosu", "print") | ("irosu", "log") | ("irosu", "so") => {
                if args.is_empty() {
                    "println!()".to_string()
                } else {
                    format!("println!(\"{{}}\", {})", args.join(", "))
                }
            }

            // ỌBÀRÀ - Math
            ("obara", "fikun") | ("obara", "add") => {
                if args.len() >= 2 {
                    format!("({} + {})", args[0], args[1])
                } else {
                    args.join(" + ")
                }
            }
            ("obara", "din") | ("obara", "sub") => {
                if args.len() >= 2 {
                    format!("({} - {})", args[0], args[1])
                } else {
                    args.join(" - ")
                }
            }

            // ÌKÁ - String operations
            ("ika", "sopo") | ("ika", "concat") => {
                format!("format!(\"{{}}{{}}\", {})", args.join(", "))
            }
            ("ika", "ka") | ("ika", "len") => {
                if let Some(arg) = args.first() {
                    format!("{}.len()", arg)
                } else {
                    "0".to_string()
                }
            }

            // ÌWÒRÌ - Time
            ("iwori", "duro") | ("iwori", "sleep") => {
                if let Some(arg) = args.first() {
                    format!(
                        "std::thread::sleep(std::time::Duration::from_millis({} as u64))",
                        arg
                    )
                } else {
                    "std::thread::sleep(std::time::Duration::from_secs(1))".to_string()
                }
            }

            // ỌYẸ̀KÚ - Exit
            ("oyeku", "ku") | ("oyeku", "exit") => {
                if let Some(arg) = args.first() {
                    format!("std::process::exit({} as i32)", arg)
                } else {
                    "std::process::exit(0)".to_string()
                }
            }
            ("oyeku", "duro") | ("oyeku", "halt") => "std::process::exit(0)".to_string(),

            // Default: generate a TODO comment
            _ => {
                format!("/* TODO: {}.{}({}) */", domain_str, method, args.join(", "))
            }
        }
    }

    fn transpile_expression(&self, expr: &Expression) -> String {
        match expr {
            Expression::Int(n) => format!("IfaValue::Int({})", n),
            Expression::Float(f) => format!("IfaValue::Float({})", f),
            Expression::String(s) => format!("IfaValue::Str(\"{}\".to_string())", s),
            Expression::Bool(b) => format!("IfaValue::Bool({})", b),
            Expression::Nil => "IfaValue::Nil".to_string(),
            Expression::Identifier(name) => name.clone(),

            Expression::BinaryOp { left, op, right } => {
                let l = self.transpile_expression(left);
                let r = self.transpile_expression(right);
                format!("({} {} {})", l, op, r)
            }

            Expression::UnaryOp { op, expr } => {
                let o = self.transpile_expression(expr);
                let op_str = match op {
                    UnaryOperator::Neg => "-",
                    UnaryOperator::Not => "!",
                };
                format!("({}{})", op_str, o)
            }

            Expression::List(items) => {
                let items_str: Vec<String> =
                    items.iter().map(|i| self.transpile_expression(i)).collect();
                format!("IfaValue::List(vec![{}])", items_str.join(", "))
            }

            Expression::Map(pairs) => {
                let pairs_str: Vec<String> = pairs
                    .iter()
                    .map(|(k, v)| {
                        format!(
                            "({}, {})",
                            self.transpile_expression(k),
                            self.transpile_expression(v)
                        )
                    })
                    .collect();
                format!("IfaValue::Map(HashMap::from([{}]))", pairs_str.join(", "))
            }

            Expression::OduCall(call) => self.transpile_odu_call(call),

            Expression::Call { name, args } => {
                let args_str: Vec<String> =
                    args.iter().map(|a| self.transpile_expression(a)).collect();
                format!("{}({})", name, args_str.join(", "))
            }

            Expression::Index { object, index } => {
                let obj = self.transpile_expression(object);
                let idx = self.transpile_expression(index);
                format!("{}[{}]", obj, idx)
            }

            Expression::MethodCall {
                object,
                method,
                args,
            } => {
                let obj = self.transpile_expression(object);
                let args_str: Vec<String> =
                    args.iter().map(|a| self.transpile_expression(a)).collect();
                format!("{}.{}({})", obj, method, args_str.join(", "))
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parse;

    #[test]
    fn test_simple_transpile() {
        let source = r#"
        ayanmo x = 10;
        Irosu.fo(x);
        "#;

        let program = parse(source).unwrap();
        let rust_code = transpile_to_rust(&program);

        assert!(rust_code.contains("let mut x"));
        assert!(rust_code.contains("fn main()"));
    }
}
