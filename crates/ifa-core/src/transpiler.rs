//! # Rust Transpiler
//!
//! Transpiles Ifá-Lang AST to Rust source code for native compilation.
//!
//! Supports all Yoruba terms like ewo (taboo), ase, ayanmo, etc.

use crate::ast::*;

/// Transpile an Ifá program to Rust source code
pub fn transpile_to_rust(program: &Program) -> String {
    let mut transpiler = RustTranspiler::new();
    transpiler.transpile_program(program)
}

struct RustTranspiler {
    indent: usize,
}

impl RustTranspiler {
    pub fn new() -> Self {
        Self { indent: 0 }
    }

    fn mangle_identifier(&self, name: &str) -> String {
        let rust_keywords = [
            "as", "break", "const", "continue", "crate", "else", "enum", "extern", "false", "fn",
            "for", "if", "impl", "in", "let", "loop", "match", "mod", "move", "mut", "pub", "ref",
            "return", "self", "Self", "static", "struct", "super", "trait", "true", "type",
            "unsafe", "use", "where", "while", "async", "await", "dyn", "abstract", "become",
            "box", "do", "final", "macro", "override", "priv", "typeof", "unsized", "virtual",
            "yield", "try",
        ];

        if rust_keywords.contains(&name) {
            format!("{}_ifa", name)
        } else {
            name.to_string()
        }
    }

    fn indent_str(&self) -> String {
        "    ".repeat(self.indent)
    }

    fn transpile_program(&mut self, program: &Program) -> String {
        let mut body = String::new();

        for stmt in &program.statements {
            body.push_str(&self.transpile_statement(stmt));
            body.push('\n');
        }

        format!(
            r#"//! Generated by Ifá-Lang Transpiler
//! Àṣẹ - May it be so

use std::collections::HashMap;

/// Ifá Value type for dynamic typing
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub enum IfaValue {{
    Int(i64),
    Float(f64),
    Str(String),
    Bool(bool),
    List(Vec<IfaValue>),
    Map(HashMap<String, IfaValue>),
    Nil,
}}

impl std::fmt::Display for IfaValue {{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {{
        match self {{
            IfaValue::Int(n) => write!(f, "{{}}", n),
            IfaValue::Float(n) => write!(f, "{{}}", n),
            IfaValue::Str(s) => write!(f, "{{}}", s),
            IfaValue::Bool(b) => write!(f, "{{}}", if *b {{ "òtítọ́" }} else {{ "èké" }}),
            IfaValue::Nil => write!(f, "àìsí"),
            IfaValue::List(l) => write!(f, "{{:?}}", l),
            IfaValue::Map(m) => write!(f, "{{:?}}", m),
        }}
    }}
}}

impl IfaValue {{
    pub fn is_truthy(&self) -> bool {{
        match self {{
            IfaValue::Bool(b) => *b,
            IfaValue::Int(n) => *n != 0,
            IfaValue::Float(f) => *f != 0.0,
            IfaValue::Str(s) => !s.is_empty(),
            IfaValue::List(l) => !l.is_empty(),
            IfaValue::Map(m) => !m.is_empty(),
            IfaValue::Nil => false,
        }}
    }}
}}

impl std::ops::Add for IfaValue {{
    type Output = Self;
    fn add(self, other: Self) -> Self {{
        match (self, other) {{
            (IfaValue::Int(a), IfaValue::Int(b)) => a.checked_add(b).map(IfaValue::Int).unwrap_or(IfaValue::Float(a as f64 + b as f64)),
            (IfaValue::Float(a), IfaValue::Float(b)) => IfaValue::Float(a + b),
            (IfaValue::Int(a), IfaValue::Float(b)) => IfaValue::Float(a as f64 + b),
            (IfaValue::Float(a), IfaValue::Int(b)) => IfaValue::Float(a + b as f64),
            (IfaValue::Str(a), IfaValue::Str(b)) => IfaValue::Str(format!("{{}}{{}}", a, b)),
            _ => IfaValue::Nil,
        }}
    }}
}}

impl std::ops::Sub for IfaValue {{
    type Output = Self;
    fn sub(self, other: Self) -> Self {{
        match (self, other) {{
            (IfaValue::Int(a), IfaValue::Int(b)) => a.checked_sub(b).map(IfaValue::Int).unwrap_or(IfaValue::Float(a as f64 - b as f64)),
            (IfaValue::Float(a), IfaValue::Float(b)) => IfaValue::Float(a - b),
            (IfaValue::Int(a), IfaValue::Float(b)) => IfaValue::Float(a as f64 - b),
            (IfaValue::Float(a), IfaValue::Int(b)) => IfaValue::Float(a - b as f64),
            _ => IfaValue::Nil,
        }}
    }}
}}

impl std::ops::Mul for IfaValue {{
    type Output = Self;
    fn mul(self, other: Self) -> Self {{
        match (self, other) {{
            (IfaValue::Int(a), IfaValue::Int(b)) => a.checked_mul(b).map(IfaValue::Int).unwrap_or(IfaValue::Float(a as f64 * b as f64)),
            (IfaValue::Float(a), IfaValue::Float(b)) => IfaValue::Float(a * b),
            (IfaValue::Int(a), IfaValue::Float(b)) => IfaValue::Float(a as f64 * b),
            (IfaValue::Float(a), IfaValue::Int(b)) => IfaValue::Float(a * b as f64),
            _ => IfaValue::Nil,
        }}
    }}
}}

impl std::ops::Div for IfaValue {{
    type Output = Self;
    fn div(self, other: Self) -> Self {{
        match (self, other) {{
            (IfaValue::Int(a), IfaValue::Int(b)) => if b != 0 {{ IfaValue::Float(a as f64 / b as f64) }} else {{ IfaValue::Nil }},
            (IfaValue::Float(a), IfaValue::Float(b)) => if b != 0.0 {{ IfaValue::Float(a / b) }} else {{ IfaValue::Nil }},
            _ => IfaValue::Nil,
        }}
    }}
}}

impl std::ops::Rem for IfaValue {{
    type Output = Self;
    fn rem(self, other: Self) -> Self {{
        match (self, other) {{
            (IfaValue::Int(a), IfaValue::Int(b)) => if b != 0 {{ IfaValue::Int(a % b) }} else {{ IfaValue::Nil }},
            _ => IfaValue::Nil,
        }}
    }}
}}

impl std::ops::Neg for IfaValue {{
    type Output = Self;
    fn neg(self) -> Self {{
        match self {{
            IfaValue::Int(a) => IfaValue::Int(-a),
            IfaValue::Float(a) => IfaValue::Float(-a),
            _ => IfaValue::Nil,
        }}
    }}
}}

impl std::ops::Not for IfaValue {{
    type Output = Self;
    fn not(self) -> Self {{
        IfaValue::Bool(!self.is_truthy())
    }}
}}

fn main() {{
{body}
    println!("\nÀṣẹ! (Success)");
}}
"#
        )
    }

    fn transpile_statement(&mut self, stmt: &Statement) -> String {
        let indent = self.indent_str();

        match stmt {
            Statement::VarDecl { name, value, .. } => {
                let m_name = self.mangle_identifier(name);
                let val = self.transpile_expression(value);
                format!("{}let mut {} = {};", indent, m_name, val)
            }

            Statement::Assignment { target, value, .. } => {
                let target_str = self.transpile_assign_target(target);
                let val = self.transpile_expression(value);
                format!("{}{} = {};", indent, target_str, val)
            }

            Statement::Instruction { call, .. } => {
                let call_str = self.transpile_odu_call(call);
                format!("{}{};", indent, call_str)
            }

            Statement::If {
                condition,
                then_body,
                else_body,
                ..
            } => {
                let cond = self.transpile_expression(condition);
                let mut result = format!("{}if ({}).is_truthy() {{\n", indent, cond);

                self.indent += 1;
                for s in then_body {
                    result.push_str(&self.transpile_statement(s));
                    result.push('\n');
                }
                self.indent -= 1;

                result.push_str(&format!("{}}}", indent));

                if let Some(else_stmts) = else_body {
                    result.push_str(" else {\n");
                    self.indent += 1;
                    for s in else_stmts {
                        result.push_str(&self.transpile_statement(s));
                        result.push('\n');
                    }
                    self.indent -= 1;
                    result.push_str(&format!("{}}}", indent));
                }

                result
            }

            Statement::While {
                condition, body, ..
            } => {
                let cond = self.transpile_expression(condition);
                let mut result = format!("{}while ({}).is_truthy() {{\n", indent, cond);

                self.indent += 1;
                for s in body {
                    result.push_str(&self.transpile_statement(s));
                    result.push('\n');
                }
                self.indent -= 1;

                result.push_str(&format!("{}}}", indent));
                result
            }

            Statement::For {
                var,
                iterable,
                body,
                ..
            } => {
                let iter = self.transpile_expression(iterable);
                let m_var = self.mangle_identifier(var);
                let mut result = format!("{}if let IfaValue::List(items) = {} {{\n", indent, iter);
                self.indent += 1;
                let indent2 = self.indent_str();
                result.push_str(&format!("{}for {} in items {{\n", indent2, m_var));

                self.indent += 1;
                for s in body {
                    result.push_str(&self.transpile_statement(s));
                    result.push('\n');
                }
                self.indent -= 1;

                result.push_str(&format!("{}}}\n", indent2));
                self.indent -= 1;
                result.push_str(&format!("{}}}", indent));
                result
            }

            Statement::Match {
                condition,
                arms,
                ..
            } => {
                let cond = self.transpile_expression(condition);
                let mut result = format!("{}let cond_val = {};\n", indent, cond);

                for (i, arm) in arms.iter().enumerate() {
                    let prefix = if i == 0 { "if" } else { "else if" };
                    let condition = match &arm.pattern {
                        MatchPattern::Literal(expr) => {
                            format!("cond_val == {}", self.transpile_expression(expr))
                        }
                        MatchPattern::Range { start, end } => {
                            let s = self.transpile_expression(start);
                            let e = self.transpile_expression(end);
                            format!("cond_val >= {} && cond_val <= {}", s, e)
                        }
                        MatchPattern::Wildcard => "true".to_string(),
                    };

                    result.push_str(&format!("{}{} {} {{\n", indent, prefix, condition));
                    self.indent += 1;
                    for s in &arm.body {
                        result.push_str(&self.transpile_statement(s));
                        result.push('\n');
                    }
                    self.indent -= 1;
                    result.push_str(&format!("{}}}\n", indent));
                }
                result.trim_end().to_string()
            }

            Statement::Return { value, .. } => {
                if let Some(v) = value {
                    format!("{}early_return = Some({}); return;", indent, self.transpile_expression(v))
                } else {
                    format!("{}return;", indent)
                }
            }

            // Ẹsẹ (function) definition
            Statement::EseDef {
                name,
                params,
                body,
                visibility,
                ..
            } => {
                let vis = match visibility {
                    Visibility::Public => "pub ",
                    _ => "",
                };
                let params_str: Vec<String> = params
                    .iter()
                    .map(|p| format!("{}: IfaValue", p.name))
                    .collect();
                let mut result = format!(
                    "{}{}fn {}({}) -> IfaValue {{\n",
                    indent,
                    vis,
                    self.mangle_identifier(name),
                    params_str.join(", ")
                );

                self.indent += 1;
                result.push_str(&format!("{}let mut early_return: Option<IfaValue> = None;\n", self.indent_str()));
                for s in body {
                    result.push_str(&self.transpile_statement(s));
                    result.push('\n');
                }
                result.push_str(&format!("{}early_return.unwrap_or(IfaValue::Nil)\n", self.indent_str()));
                self.indent -= 1;

                result.push_str(&format!("{}}}", indent));
                result
            }

            // Odù (class) definition
            Statement::OduDef {
                name,
                body,
                visibility,
                ..
            } => {
                let vis = match visibility {
                    Visibility::Public => "pub ",
                    _ => "",
                };
                let mut struct_fields = Vec::new();
                let mut methods = Vec::new();

                for stmt in body {
                    match stmt {
                        Statement::VarDecl { name, type_hint, .. } => {
                            let type_str = match type_hint {
                                Some(TypeHint::Int) => "i64",
                                Some(TypeHint::Float) => "f64",
                                Some(TypeHint::Str) => "String",
                                Some(TypeHint::Bool) => "bool",
                                _ => "IfaValue",
                            };
                            struct_fields.push(format!("    pub {}: {},", name, type_str));
                        }
                        Statement::EseDef { .. } => {
                            methods.push(stmt.clone());
                        }
                        _ => {}
                    }
                }

                let indent = self.indent_str();
                let m_name = self.mangle_identifier(name);
                let mut result = format!("{}{}struct {} {{\n", indent, vis, m_name);
                for field in struct_fields {
                    result.push_str(&format!("{}{}\n", indent, field));
                }
                result.push_str(&format!("{}}}\n\n", indent));
 
                if !methods.is_empty() {
                    result.push_str(&format!("{}{}impl {} {{\n", indent, vis, m_name));
                    self.indent += 1;
                    for method in methods {
                        result.push_str(&self.transpile_statement(&method));
                        result.push('\n');
                    }
                    self.indent -= 1;
                    result.push_str(&format!("{}}}\n", indent));
                }
                result
            }

            Statement::Import { path, .. } => {
                format!("{}// use {};", indent, path.join("::"))
            }

            // Àṣẹ - End/success statement
            Statement::Ase { .. } => {
                format!("{}std::process::exit(0);", indent)
            }

            // Èèwọ̀ - Taboo declaration (compile-time check, no runtime code)
            Statement::Taboo { source, target, .. } => {
                format!("{}// TABOO: {} cannot call {}", indent, source, target)
            }

            // Ewo - Runtime assertion
            Statement::Ewo {
                condition, message, ..
            } => {
                let cond = self.transpile_expression(condition);
                let msg = message
                    .clone()
                    .unwrap_or_else(|| "Assertion failed".to_string());
                format!("{}assert(({}).is_truthy(), \"{}\");", indent, cond, msg)
            }

            // Opon - Memory configuration directive (compile-time)
            Statement::Opon { size, .. } => {
                format!("{}// OPON: Memory size = {}", indent, size)
            }

            // Expression statement
            Statement::Expr { expr, .. } => {
                format!("{}{};", indent, self.transpile_expression(expr))
            }

            // Ẹbọ - Sacrifice/aspect directive
            Statement::Ebo { offering, .. } => {
                let val = self.transpile_expression(offering);
                format!("{}// EBO: Initiating aspect with {}", indent, val)
            }
        }
    }

    fn transpile_assign_target(&self, target: &AssignTarget) -> String {
        match target {
            AssignTarget::Variable(name) => self.mangle_identifier(name),
            AssignTarget::Index { name, index } => {
                format!("{}[{}]", self.mangle_identifier(name), self.transpile_expression(index))
            }
        }
    }

    fn transpile_odu_call(&self, call: &OduCall) -> String {
        let args: Vec<String> = call
            .args
            .iter()
            .map(|a| self.transpile_expression(a))
            .collect();

        // Map Odù domain calls to Rust implementations
        let domain_str = format!("{:?}", call.domain).to_lowercase();
        let method = call.method.to_lowercase();

        match (domain_str.as_str(), method.as_str()) {
            // ÌROSÙ (1100) - Console I/O
            ("irosu", "fo") | ("irosu", "sọ") | ("irosu", "print") => {
                format!("println!(\"{{}}\", {})", args.join(", "))
            }
            ("irosu", "ka") | ("irosu", "input") => {
                "{ let mut s = String::new(); std::io::stdin().read_line(&mut s).ok(); IfaValue::Str(s.trim().to_string()) }".to_string()
            }

            // ỌBÀRÀ (1000) - Math (Add/Mul)
            ("obara", "fikun") | ("obara", "add") => {
                args.join(" + ")
            }
            ("obara", "isodipupo") | ("obara", "mul") => {
                args.join(" * ")
            }

            // ÒTÚÚRÚPỌ̀N (0010) - Math (Sub/Div)
            ("oturupon", "din") | ("oturupon", "sub") => {
                if args.len() >= 2 {
                    format!("({} - {})", args[0], args[1])
                } else {
                    args.join(" - ")
                }
            }
            ("oturupon", "pin") | ("oturupon", "div") => {
                if args.len() >= 2 {
                    format!("({} / {})", args[0], args[1])
                } else {
                    args.join(" / ")
                }
            }

            // ÌKÁ (0100) - Strings
            ("ika", "so") | ("ika", "concat") => {
                format!("format!(\"{{}}{{}}\", {})", args.iter().map(|a| a.to_string()).collect::<Vec<_>>().join(", "))
            }
            ("ika", "gigun") | ("ika", "len") => {
                if let Some(arg) = args.first() {
                    format!("IfaValue::Int(if let IfaValue::Str(s) = {} {{ s.chars().count() as i64 }} else {{ 0 }})", arg)
                } else {
                    "IfaValue::Int(0)".to_string()
                }
            }

            // Ọ̀YÈKÚ (0000) - Exit/Sleep
            ("oyeku", "jade") | ("oyeku", "exit") => {
                if let Some(arg) = args.first() {
                    format!("std::process::exit(match {} {{ IfaValue::Int(n) => n as i32, _ => 0 }})", arg)
                } else {
                    "std::process::exit(0)".to_string()
                }
            }
            ("oyeku", "sun") | ("oyeku", "sleep") => {
                if let Some(arg) = args.first() {
                    format!(
                        "std::thread::sleep(std::time::Duration::from_millis(match {} {{ IfaValue::Int(n) => n as u64, _ => 1000 }}))",
                        arg
                    )
                } else {
                    "std::thread::sleep(std::time::Duration::from_secs(1))".to_string()
                }
            }

            // ÒGÚNDÁ (1110) - Arrays
            ("ogunda", "da") | ("ogunda", "create") => {
                format!("IfaValue::List(vec![{}])", args.join(", "))
            }
            ("ogunda", "gigun") | ("ogunda", "len") => {
                if let Some(arg) = args.first() {
                    format!("IfaValue::Int(if let IfaValue::List(l) = {} {{ l.len() as i64 }} else {{ 0 }})", arg)
                } else {
                    "IfaValue::Int(0)".to_string()
                }
            }

            // Default: generate a TODO comment
            _ => {
                format!("/* TODO: {}.{}({}) */ IfaValue::Nil", domain_str, method, args.join(", "))
            }
        }
    }

    fn transpile_expression(&self, expr: &Expression) -> String {
        match expr {
            Expression::Int(n) => format!("IfaValue::Int({})", n),
            Expression::Float(f) => format!("IfaValue::Float({})", f),
            Expression::String(s) => format!("IfaValue::Str(\"{}\".to_string())", s),
            Expression::Bool(b) => format!("IfaValue::Bool({})", b),
            Expression::Nil => "IfaValue::Nil".to_string(),
            Expression::Identifier(name) => self.mangle_identifier(name),
 
            Expression::BinaryOp { left, op, right } => {
                let l = self.transpile_expression(left);
                let r = self.transpile_expression(right);
                match op {
                    BinaryOperator::Eq => format!("IfaValue::Bool({} == {})", l, r),
                    BinaryOperator::NotEq => format!("IfaValue::Bool({} != {})", l, r),
                    BinaryOperator::Lt => format!("IfaValue::Bool({} < {})", l, r),
                    BinaryOperator::LtEq => format!("IfaValue::Bool({} <= {})", l, r),
                    BinaryOperator::Gt => format!("IfaValue::Bool({} > {})", l, r),
                    BinaryOperator::GtEq => format!("IfaValue::Bool({} >= {})", l, r),
                    BinaryOperator::And => format!("IfaValue::Bool(({}).is_truthy() && ({}).is_truthy())", l, r),
                    BinaryOperator::Or => format!("IfaValue::Bool(({}).is_truthy() || ({}).is_truthy())", l, r),
                    _ => format!("({} {} {})", l, op, r),
                }
            }

            Expression::UnaryOp { op, expr } => {
                let o = self.transpile_expression(expr);
                match op {
                    UnaryOperator::Neg => format!("(-{})", o),
                    UnaryOperator::Not => format!("(!{})", o),
                }
            }

            Expression::List(items) => {
                let items_str: Vec<String> =
                    items.iter().map(|i| self.transpile_expression(i)).collect();
                format!("IfaValue::List(vec![{}])", items_str.join(", "))
            }

            Expression::Map(pairs) => {
                let pairs_str: Vec<String> = pairs
                    .iter()
                    .map(|(k, v)| {
                        format!(
                            "({}, {})",
                            self.transpile_expression(k),
                            self.transpile_expression(v)
                        )
                    })
                    .collect();
                format!("IfaValue::Map(HashMap::from([{}]))", pairs_str.join(", "))
            }

            Expression::OduCall(call) => self.transpile_odu_call(call),

            Expression::Call { name, args } => {
                let args_str: Vec<String> =
                    args.iter().map(|a| self.transpile_expression(a)).collect();
                format!("{}({})", name, args_str.join(", "))
            }

            Expression::Index { object, index } => {
                let obj = self.transpile_expression(object);
                let idx = self.transpile_expression(index);
                format!("{}[{}]", obj, idx)
            }

            Expression::MethodCall {
                object,
                method,
                args,
            } => {
                let obj = self.transpile_expression(object);
                let args_str: Vec<String> =
                    args.iter().map(|a| self.transpile_expression(a)).collect();
                format!("{}.{}({})", obj, method, args_str.join(", "))
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parse;

    #[test]
    fn test_simple_transpile() {
        let source = r#"
        ayanmo x = 10;
        Irosu.fo(x);
        "#;

        let program = parse(source).unwrap();
        let rust_code = transpile_to_rust(&program);

        assert!(rust_code.contains("let mut x"));
        assert!(rust_code.contains("fn main()"));
    }
}
